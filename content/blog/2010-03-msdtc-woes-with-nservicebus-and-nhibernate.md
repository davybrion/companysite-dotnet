<p>I’ve spent about 3 days trying to get something working that should’ve just worked.&#160; I basically wanted some .NET code to use a distributed transaction to update some data in a database, and then publish a message on the service bus.&#160; I want to do this in a distributed transaction because if something goes wrong, i want to roll back both transactions (the database change and the published message).&#160; Normally, this should just work if you have MS DTC configured correctly.&#160; On my machine, i enabled Network DTC Access, and allowed outbound transaction communication.&#160; On the database server, Network DTC Access was already enabled and both outbound and inbound communication was allowed.&#160; </p>  <p>Now the thing is, i’d either expect DTC to fail outright or to just work.&#160; But it shouldn’t fail in one situation, and work in another.&#160; On my machine, it failed in the following situation (which i’ll further refer to as Situation A):</p>  <ol>   <li>open a transaction scope </li>    <li>open an nhibernate session </li>    <li>hit the db </li>    <li>publish a message through nservicebus </li>    <li>close the nhibernate session </li>    <li>complete and close the transaction scope </li> </ol>  <p>Step 4 and 5 could be switched around but it didn’t make a difference.&#160; In Situation A, i always got a TransactionManagerCommunicationException with the following message:</p>  <blockquote>   <p>Network access for Distributed Transaction Manager (MSDTC) has been disabled. Please enable DTC for network access in the security configuration for MSDTC using the Component Services Administrative tool.</p> </blockquote>  <p>Everyone who’s worked with MSDTC before probably knows that exception since it usually takes some fiddling with the settings to make things work.&#160; The thing is, i was pretty sure that my settings, as well as the ones on the database server were correct.&#160; Unfortunately, DTCPing didn’t confirm that since that too failed.</p>  <p>However, i also tried the following sequence of events (Situation B):</p>  <ol>   <li>open a transaction scope </li>    <li>open an nhibernate session </li>    <li>publish a message </li>    <li>hit the db </li>    <li>close the nhibernate session </li>    <li>complete and close the transaction scope </li> </ol>  <p>And guess what.&#160; That actually worked.&#160; With full DTC transaction semantics.&#160; The DTC statistics on the server confirmed that it was indeed using a DTC transaction, and if i made the code fail with an exception both the database action and the published message were correctly rolled back.</p>  <p>So the question is: why on earth does it only work when i publish a message before i hit the db?</p>  <p>During my investigation i noticed that in Situation A, the internal transaction that the transaction scope was using was a SqlDelegatedTransaction.&#160; Which, if i’m not mistaken is an LTM transaction.&#160; When trying to send a message to a message queue, the transaction manager tries to promote the current transaction to an OletxCommittableTransaction since the OleTx transaction protocol is required when using MSMQ (it doesn’t support LTM transactions).&#160; For some reason, promoting the SqlDelegatedTransaction to a full DTC (OleTx) transaction fails on my machine.</p>  <p>In Situation B, the internal transaction is promoted to an OletxCommittableTransaction as soon as you try to send the message to a message queue.&#160; Once it’s time to hit the DB, NHibernate nicely works together with the OletxCommittableTransaction and everything just works. </p>  <p>Now, i have no idea on earth why promotion of a SqlDelegatedTransaction fails, but after a long number of attempts and experiments to get it working correctly, i sorta gave up and figured i’d have to resort to a hack.&#160; What i basically needed was for the transaction scope’s internal transaction to automatically be promoted to an OletxCommittableTransaction <em>before<strong> </strong></em>i’d hit the database and without having to publish a dummy message at the beginning of the transaction.</p>  <p>I found one way of doing this which, while being a huge hack, is still relatively clean i think.&#160; I wrote the following class:</p>  <div style="font-family: consolas; background: white; color: black; font-size: 10pt">   <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">DummyEnlistmentNotification</span> : <span style="color: #2b91af">IEnlistmentNotification</span></p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: blue">readonly</span> <span style="color: #2b91af">Guid</span> Id = <span style="color: blue">new</span> <span style="color: #2b91af">Guid</span>(<span style="color: #a31515">&quot;E2D35055-4187-4ff5-82A1-F1F161A008D0&quot;</span>);</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> Prepare(<span style="color: #2b91af">PreparingEnlistment</span> preparingEnlistment)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; preparingEnlistment.Prepared();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> Commit(<span style="color: #2b91af">Enlistment</span> enlistment)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; enlistment.Done();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> Rollback(<span style="color: #2b91af">Enlistment</span> enlistment)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; enlistment.Done();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> InDoubt(<span style="color: #2b91af">Enlistment</span> enlistment)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; enlistment.Done();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p> </div>  <p>&#160;</p>  <p>Then, right after opening the transaction scope and before doing anything else, i do this:</p>  <div style="font-family: consolas; background: white; color: black; font-size: 10pt">   <p style="margin: 0px">&#160;&#160;&#160; <span style="color: #2b91af">Transaction</span>.Current.EnlistDurable(<span style="color: #2b91af">DummyEnlistmentNotification</span>.Id, <span style="color: blue">new</span> <span style="color: #2b91af">DummyEnlistmentNotification</span>(), <span style="color: #2b91af">EnlistmentOptions</span>.None);</p> </div>  <p>&#160;</p>  <p>This basically tells the System.Transactions infrastructure that we’re adding our own Resource Manager to the current transaction.&#160; And because it’s a durable Resource Manager, it now automatically promotes the internal transaction to an OletxCommittableTransaction and everything just works.&#160; While our Resource Manager participates in the 2-phase-commit process, it doesn’t actually do anything.&#160; It’s sole purpose is to force the creation of an OletxCommittableTransaction.</p>  <p>Like i said, it’s a hack but it’s still relatively clean.&#160; I still have no idea why i needed to resort to this hack though… If anyone can shed some light on this, i’d highly appreciate it :)</p>  <p>Also, if you ever want to learn more about transactions in .NET or distributed transactions in particular, you really need to check out <a href="http://www.codeproject.com/KB/WCF/NETTx.aspx" target="_blank">this article</a>.&#160; Without it, i probably wouldn’t have figured out what to do :)</p>