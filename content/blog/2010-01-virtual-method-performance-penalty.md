<p>You often hear/read that one of the reasons why C# methods aren’t virtual by default is because of performance.&#160; Calling a virtual method is more expensive than calling a regular instance method, because the CLR has to determine the correct override to call at runtime, instead of being able to simply call the instance method directly.&#160; Another reason why virtual methods are more expensive to call is because they can never be inlined.</p>  <p>Is it really that much more expensive though? I ran a little experiment and i’d like to share the results with you.</p>  <p>Suppose you have the following 2 classes:</p>  <div style="font-family: consolas; background: white; color: black; font-size: 10pt">   <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">MyClass</span></p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">protected</span> <span style="color: blue">long</span> someLong;</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> IncreaseLong()</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; someLong++;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">virtual</span> <span style="color: blue">void</span> VirtualIncreaseLong()</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; someLong++;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">MyDerivedClass</span> : <span style="color: #2b91af">MyClass</span></p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">override</span> <span style="color: blue">void</span> VirtualIncreaseLong()</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; someLong += 2;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p> </div>  <p>&#160;</p>  <p>As you can see, there is no difference between the IncreaseLong and VirtualIncreaseLong methods, except that the latter is virtual and the former is a regular instance method.&#160; According to many people, calling VirtualIncreaseLong instead of IncreaseLong will be more expensive.&#160; I also have a derived class which overrides the VirtualIncreaseLong method with a slightly different implementation.</p>  <p>If we call these methods a bunch of times (like 1000000000 times), we should notice quite a difference according to many people.</p>  <p>I wrote the following test code which calls these methods a bunch of times, times it, and outputs the results.</p>  <div style="font-family: consolas; background: white; color: black; font-size: 10pt">   <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">class</span> <span style="color: #2b91af">Program</span></p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">const</span> <span style="color: blue">int</span> numberOfTimes = 1000000000;</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">static</span> <span style="color: blue">void</span> Main(<span style="color: blue">string</span>[] args)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">var</span> myObject = <span style="color: blue">new</span> <span style="color: #2b91af">MyClass</span>();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">var</span> myDerivedObject = <span style="color: blue">new</span> <span style="color: #2b91af">MyDerivedClass</span>();</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: green">// we do this so there's no first-time performance cost while timing</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; EnsureThatEverythingHasBeenJitted(myObject);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; EnsureThatEverythingHasBeenJitted(myDerivedObject);</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TestNormalIncreaseMethod(myObject);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TestVirtualIncreaseMethod(myObject);</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TestNormalIncreaseMethod(myDerivedObject);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; TestVirtualIncreaseMethod(myDerivedObject);</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">Console</span>.ReadLine();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">static</span> <span style="color: blue">void</span> EnsureThatEverythingHasBeenJitted(<span style="color: #2b91af">MyClass</span> theObject)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; theObject.IncreaseLong();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; theObject.VirtualIncreaseLong();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">static</span> <span style="color: blue">void</span> TestNormalIncreaseMethod(<span style="color: #2b91af">MyClass</span> theObject)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">Console</span>.WriteLine(<span style="color: blue">string</span>.Format(<span style="color: #a31515">&quot;calling the IncreaseLong method of type {0} {1} times&quot;</span>, theObject.GetType().Name, numberOfTimes));</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">var</span> stopwatch = <span style="color: #2b91af">Stopwatch</span>.StartNew();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">for</span> (<span style="color: blue">var</span> i = 0; i &lt; numberOfTimes; i++)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; theObject.IncreaseLong();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stopwatch.Stop();</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">Console</span>.WriteLine(<span style="color: #a31515">&quot;Elapsed milliseconds: &quot;</span> + stopwatch.ElapsedMilliseconds);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">static</span> <span style="color: blue">void</span> TestVirtualIncreaseMethod(<span style="color: #2b91af">MyClass</span> theObject)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">Console</span>.WriteLine(<span style="color: blue">string</span>.Format(<span style="color: #a31515">&quot;calling the VirtualIncreaseLong method of type {0} {1} times&quot;</span>, theObject.GetType().Name, numberOfTimes));</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">var</span> stopwatch = <span style="color: #2b91af">Stopwatch</span>.StartNew();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">for</span> (<span style="color: blue">var</span> i = 0; i &lt; numberOfTimes; i++)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; theObject.VirtualIncreaseLong();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; stopwatch.Stop();</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">Console</span>.WriteLine(<span style="color: #a31515">&quot;Elapsed milliseconds: &quot;</span> + stopwatch.ElapsedMilliseconds);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p> </div>  <p>&#160;</p>  <p>The output of running this code might surprise you.&#160; On my machine, i got the following results when the code was compiled in debug mode:</p>  <p><a href="http://davybrion.com/blog/wp-content/uploads/2010/01/manual_compile_debug.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="manual_compile_debug" border="0" alt="manual_compile_debug" src="http://davybrion.com/blog/wp-content/uploads/2010/01/manual_compile_debug_thumb.png" width="753" height="161" /></a> </p>  <p>The difference between calling the regular instance method and the virtual method is quite small.&#160; I’d even say it’s negligible.</p>  <p>When compiling in release mode, i got the following output:</p>  <p><a href="http://davybrion.com/blog/wp-content/uploads/2010/01/manual_compile_optimized.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="manual_compile_optimized" border="0" alt="manual_compile_optimized" src="http://davybrion.com/blog/wp-content/uploads/2010/01/manual_compile_optimized_thumb.png" width="757" height="171" /></a> </p>  <p>I ran the test a bunch of times, and there was no consistent observable performance penalty when calling the virtual methods.&#160; In fact, the virtual methods often performed faster than the regular instance methods and in most cases were equally fast.&#160; I’m not claiming that virtual methods are faster than regular instance methods, but if there really was an extra <em>real-world </em>performance cost associated with virtual methods, it surely should be observable with this test code, no?</p>  <p>Obviously, this test isn’t scientific in any way.&#160; But still, i think it does show that the so called performance cost associated with virtual methods is highly overrated.&#160; There definitely will be cases where virtual methods are more expensive than regular instance methods, but i’m willing to bet that those cases are rare and that the vast majority of .NET developers will never be negatively impacted by it.&#160; </p>  <p>Side note: have you ever noticed that most people who recommend to avoid virtual methods due to their performance cost never put the same emphasis on avoiding the cost of say, frequent remote operations?&#160; Which is odd, since i wouldn’t be surprised if that would be the most common reason for performance problems with .NET applications.&#160; Then again, that’s what you get when the biggest company pushing a platform advocates meaningless performance improvements while at the same time pushing bad architectural decisions/guidelines on the world because the resulting code is supposedly easier to write, use and maintain.</p>  <p>You can download the example code <a href="http://davybrion.com/VirtualMethodsPerformance.zip" target="_blank">here</a> so you can run the test yourself.&#160; </p>