<p>I sometimes still get questions from people who want to expose their entities through their WCF Services.&#160; Regardless of whether these are entities that are populated through NHibernate or any other ORM, this is just not a good thing to do.&#160; Many people prefer to accept and return entities through their services because they believe this is an easier programming model.&#160; They believe that it takes less work than mapping to DTO’s and that as a whole, this solution is much more manageable.&#160; Rest assured that this is a fallacy.&#160; Any perceived benefit that you’ll get from exposing entities outside of your service layer will only last a <em>very short time</em> and will quickly be dwarfed by added complexity, increased maintenance overhead and a performance overhead which must not be ignored.&#160; </p>  <p>In this post, i’d like to take the chance to explain the downsides to exposing entities through services.&#160; Though i’ll probably miss quite a few of the downsides (feel free to add to the list through comments), the ones i will mention are IMO important enough to take note of.</p>  <p><strong>Exposing entities to clients means your clients are very tightly coupled to your service(s)</strong></p>  <p>Entities are a part of your domain.&#160; These entities in your domain can change for various reasons.&#160; Sometimes because functional changes are required, but quite often also for optimizations (whether they are for performance reasons or to improve the clarity and maintainability of your domain).&#160; Functional changes <em>can </em>impact your clients, though that is not necessarily the case.&#160; Optimizations hardly ever have an impact on your clients (other than possibly improved response times from your service calls obviously).&#160; If your service layer accepts and returns domain entities, each possible change is highly likely to have an impact on your clients.&#160; And this impact is not cheap.&#160; In the best case scenario, it means updating your service contracts, regenerating your service proxies and redeploying your clients.&#160; In the worst case scenario, it means making actual changes to the code of your clients.&#160; And for what? Because of changes that shouldn’t have impacted your clients in the first place? </p>  <p>Ideally, your clients are as dumb as they can be.&#160; They should know as little as possible about the actual <em>implementation</em> of the domain because that implementation is simply not relevant to them.&#160; They should present users with data and give them the option to modify that data, to trigger actions and to perform certain tasks.&#160; They should focus squarely on those tasks and pretty much everything else is typically better suited to be done behind your service layer.&#160; If you build your clients with no real knowledge of the actual domain model, but of DTO’s and possible actions to be performed then you can reduce the level of coupling between your clients and your services substantially. </p>  <p>Many of the people who prefer to expose entities often claim that going for the DTO approach introduces too much extra work and too many extra, seemingly unnecessary classes.&#160; For starters, they don’t want to write code that maps entities to DTO’s.&#160; First of all, the amount of code that this requires is in reality <em>very small</em>, not to mention <em>very easy</em>.&#160; Secondly, you can just as well use a library such as AutoMapper to take that pain away from you.&#160; And contrary to what you might think, there is a big performance gain to be had from returning DTO’s over entities, but i’ll get to that in the next section.</p>  <h5></h5>  <h5></h5>  <p><strong>Entities are hardly ever the most optimal representation of data</strong></p>  <p>I think we can safely say that most applications need to show data in the following 3 ways:</p>  <ul>   <li>In a grid view, either as a total listing of all instances of a certain type of data or the result of a search query or some kind of filtering action </li>    <li>In dropdown controls or anything else that lets users select pieces of data </li>    <li>In edit screens where a piece of data needs to be displayed in its entirety, perhaps even to be modified by the user </li> </ul>  <p>There are undoubtedly more ways in which data can be presented to the user but i think it’s safe to say that most business applications will certainly rely on the following 3 ways quite heavily.</p>  <p>In the case of a grid view, you’re frequently showing data that is related to more than one entity.&#160; You’ll often need to include the name or the description of some associated entities.&#160; So what exactly is it that you want to do in this situation?&#160; Do you want to return a list of the main entities of the grid view, which all have their required association properties filled in so you can display the columns that you need in the grid view?&#160; Do you actually need all of the properties of these entities (for both the main entities and the associated entities)?&#160; Odds are high that you’re going to be returning a lot more data to the client than you actually need.&#160; And that is what is realistically going to hurt the performance of your system.&#160; Any piece of unnecessary data that you transmit to your clients has a cost associated with it.&#160; The unnecessary data is retrieved from the database.&#160; The entities are then serialized at the service end.&#160; Then they are transmitted to the client.&#160; Then they are deserialized by your client.&#160; All of this is pretty costly, so the more unnecessary data that is included in this operation, the more your performance and the responsiveness of your client (not to mention your database and your server) is impacted negatively.</p>  <p>In the case of dropdown controls or anything else that lets users select pieces of data, you typically only need very few of the properties of that piece of data.&#160; In many cases, the primary key and a name or a description are sufficient.&#160; Do you really need to transmit the entire entity every time for usages like this? Again, keep in mind that all of that extra data that will never be used by your client needs to be retrieved, serialized, transmitted and deserialized again.&#160; Surely, this is an awful waste, no?&#160; </p>  <p>And then there’s the case where a piece of data needs to be displayed in its entirety.&#160; In these cases, you will almost always need all of the properties of the entity that is displayed, but you’ll most often also need to show other data (things that can be selected, or linked to the main entity).&#160; This other data will in most cases fall into the previous category where you’ll only need very little information about the actual entity.&#160; If you’re smart, you’ve chosen the DTO approach to retrieve this data for the data that can be selected, and in that case, you already have all of the infrastructural code in place to project entities or data into DTO’s.&#160; So you might as well reuse it for the main entity as well since you already have the capability to do this.</p>  <p>Always keep in mind that your entities will frequently either contain <em>more data than needed</em>, or <em>less data than needed</em>.&#160; As such, it just doesn’t make much sense to expose entities to your clients since they are hardly ever optimal for client-side usage.&#160; If you really want to think about performance, stop worrying about the supposed cost of mapping to DTO’s (which is truly negligible) and start focusing on <em>what</em> your actually <em>sending</em> to and from your service because this is far more costly than any kind of DTO-mapping really is. </p>  <p><strong>Must your data really come from entities?</strong></p>  <p>If you are displaying data to your user, does that data really need to come from your domain model?&#160; Does it really need to be retrieved by populating a collection of entities to then return them to the client?&#160; Again, keep the <em>form</em> of the data in mind when thinking about this.&#160; In many cases, as i mentioned above, an entity is not the most optimal form of the data that your client needs.&#160; So why even retrieve it through entities? Sure, asking your ORM to retrieve a set of entities based on a set of criteria is often the easiest thing to do, but if the easiest path were the best path, the overall quality of software projects wouldn’t be in the sad state that it’s in today.&#160; If the form of the required data is not identical to the structure of an entity, it’s often far more optimal to simply populate a DTO <em>directly from the data.</em>&#160; With NHibernate, you can easily do this by adding a list of projections to your query and then using a ResultTransformer to populate the DTO’s based on the direct output of the query.&#160; In this case, no entity instance ever needs to be created when you’re just retrieving data, and no extra mapping between the entity and the DTO’s needs to be performed.&#160; Your data access code simply retrieves the resulting data from a query, and puts that data directly in your DTO’s.&#160; There’s no reason why usage of an ORM should prevent you from doing this.&#160;&#160; Once again, this approach will offer far more performance benefits than avoiding DTO mapping at all costs ever can.</p>  <p><strong>What about the behavior of your entities?</strong></p>  <p>Do your entities have any behavior in them?&#160; If not, they are already more of a DTO than a true entity.&#160; In fact, if your entities have no behavior at all, you could even wonder why you’re using an ORM in the first place.&#160; Now, behavior can mean many things.&#160; It could mean lazy loading of associations.&#160; It could mean actual business logic.&#160; Obviously, lazy-loading doesn’t (and shouldn’t!) work client-side, but what about your business logic? Do you have business logic that <em>can </em>be executed client-side? Or is it business logic that should only be executed behind the service layer? If so, how do you make the distinction between this to prevent client-side usage from these entities? Whatever you do, you’re pretty much opening up a can of worms that really is better avoided in the first place.</p>  <p><strong>How are you going to deal with technical issues?</strong></p>  <p>Accepting and returning entities from services introduces a host of technical issues that can be quite substantial.&#160; Serialization and deserialization specifically are issues that you need to be worried about.&#160; If you’re using an ORM which does lazy-loading of associations, this will certainly cause serialization issues that you need to work around.&#160; You can either disable lazy loading, or you can make sure that your entities are always fully initialized (as in: always have their associations fully loaded) before they are sent back to the client.&#160; Disabling lazy-loading <em>will </em>cause performance problems in your service layer, either in places where you don’t expect them to be or in places that you haven’t thought of before it’s too late.&#160; Fully loading your entities and their associates before returning them is another performance nightmare waiting to happen so that’s really not an ideal solution either.&#160; You can try to hook into the serialization process or even the lazy-loading features of your ORM but whatever you do in that case will be a hack that <em>will</em> cause issues sooner or later.&#160; And again, all of these problems can very easily be avoided with a solution which, i hope you realize by now, offers plenty more benefits than any solution where you accept/return entities in your service.</p>  <p><strong>Conclusion</strong></p>  <p>Every single downside to exposing entities through services are issues that i have myself encountered in past projects, either ones i’ve worked on myself, or ones that i’ve seen other people work on.&#160; If that’s not enough for you, then maybe you’ll find it interesting to know that some of the brightest and most respected people (like Udi Dahan and Ayende for instance) in the .NET community also actively recommend against exposing entities through services because of the same downsides that i mentioned, though they could probably give you even more downsides that i forgot to cover in this post.&#160; These downsides are not figments of anyone’s imagination.&#160; They are very real, and you really, really ought to think twice before dismissing this advice.&#160; </p>