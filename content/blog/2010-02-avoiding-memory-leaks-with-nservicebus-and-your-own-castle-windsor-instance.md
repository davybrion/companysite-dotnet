<p>If you’re using NServiceBus together with your own instance of Castle Windsor, there is one thing you really need to look out for.&#160; NServiceBus was originally developed with Spring.NET as its IoC container, but it’s been changed to support multiple containers in a similar manner as <a href="http://davybrion.com/blog/2009/11/integrating-your-ioc-container-with-agatha/" target="_blank">Agatha does it</a>.&#160; Agatha however, was originally developed with Castle Windsor as its IoC container, and as such is well aware of Windsor’s <a href="http://davybrion.com/blog/2008/12/the-importance-of-releasing-your-components-through-windsor/" target="_blank">need to explicitly release resolved components</a>.&#160;&#160; NServiceBus unfortunately was <a href="http://tech.groups.yahoo.com/group/nservicebus/message/5376" target="_blank">not aware of this need</a>, and a workaround that they have introduced is to set Windsor’s ReleasePolicy to the NoTrackingReleasePolicy (which doesn’t hold any instances in memory, but doesn’t provide any cleanup either) if you configure NServiceBus to use <em>its own instance of </em>Castle Windsor.&#160; However, if you’re integrating NServiceBus into a project that is already using Castle Windsor, then you probably want NServiceBus to use <em>your instance</em> of Castle Windsor.</p>  <p>And that is when problems might appear.&#160; If you’re using Castle Windsor with the default ReleasePolicy (which is the LifecycledComponentsReleasePolicy) then each resolved transient instance will be stored in memory by that policy until the instance is explicitly released.&#160; The benefit of this policy is that the container can automatically dispose any disposable transient dependency of a resolved component.&#160; In my case, i’ve come to rely on that feature to achieve deterministic disposal behavior throughout my code base.&#160; </p>  <p>Now, when you configure NServiceBus and pass it your instance of Castle Windsor, it obviously doesn’t change the ReleasePolicy like it does when it creates its own instance of Castle Windsor.&#160;&#160; This is good because changing the policy of a passed in container would almost certainly have a huge behavioral implication for the application and such an action would be unacceptable when integrating a new framework into your project.&#160;&#160; But since NServiceBus doesn’t have the notion of needing to release resolved components, every single transient instance it resolves through <em>your</em> container will be stored in memory until the application’s process is terminated.&#160; Which means that you’ll leak instances of the following types <em>for each message</em> that your system needs to handle:</p>  <ul>   <li>NServiceBus.Grid.MessageHandlers.GridInterceptingMessageHandler </li>    <li>NServiceBus.Sagas.Impl.SagaMessageHandler </li>    <li>Your own MessageHandlers (and their transient dependencies as well) </li> </ul>  <p>If your MessageHandlers don’t have dependencies (highly unlikely if you’re already using an IOC container) then you’d still have 3 leaking instances per incoming message.&#160; Add the number of transient dependencies of any handler to that and the number of leaking instances can increase dramatically.</p>  <p>First of all, if you do not depend on Windsor’s default ReleasePolicy’s behavior, then the easiest way to avoid this problem is definitely to set the container’s ReleasePolicy to the NoTrackingReleasePolicy like NServiceBus does itself when it’s configuring itself with a new instance of the container.</p>  <p>If you do depend on it, and you don’t want leaking instances that hang around forever, then the approach listed below is one way to solve this problem.&#160; There are probably other solutions available, and while the approach listed below can definitely be considered to be a HACK, i do think it’s the best solution to this particular problem.</p>  <p>Because we don’t want to change anything about the way that we’re already using the container, we just need to make sure that NServiceBus’ usage of the container doesn’t conflict with ours.&#160; That basically means that we need to make sure that the components that it resolves should not be tracked by the container.&#160;&#160; There are 2 kinds of components that NServiceBus will resolve during normal operation:</p>  <ol>   <li>Its own components that it needs to implement the features it offers you </li>    <li>Your message handlers that you need to handle incoming messages </li> </ol>  <p>The first category is easy to exclude from Windsor’s tracking behavior.&#160; We can simply create our own ReleasePolicy which extends the default ReleasePolicy, and make sure that any instances of an NServiceBus-type are no longer tracked by the container:</p>  <div style="font-family: consolas; background: white; color: black; font-size: 10pt">   <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">MyReleasePolicy</span> : Castle.MicroKernel.Releasers.<span style="color: #2b91af">LifecycledComponentsReleasePolicy</span></p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">override</span> <span style="color: blue">void</span> Track(<span style="color: blue">object</span> instance, Castle.MicroKernel.<span style="color: #2b91af">Burden</span> burden)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">if</span> (!instance.GetType().FullName.StartsWith(<span style="color: #a31515">&quot;NServiceBus&quot;</span>))</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">base</span>.Track(instance, burden);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p> </div>  <p>&#160;</p>  <p>Then you need to set this release policy somewhere in your application’s startup routine:</p>  <div style="font-family: consolas; background: white; color: black; font-size: 10pt">   <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">IoC</span>.Container.Kernel.ReleasePolicy = <span style="color: blue">new</span> <span style="color: #2b91af">MyReleasePolicy</span>();</p> </div>  <p>&#160;</p>  <p>(in this case, IoC.Container returns an IWindsorContainer instance)</p>  <p>This will make sure that no instances of NServiceBus-types will ever leak in the container.&#160; But now we still have to deal with our message handlers.&#160; The solution to making sure they are not disposed is not the cleanest out there but hey, it works.&#160; I basically introduced a base class that all my message handlers will need to inherit from, with the following implementation in the Handle method:</p>  <div style="font-family: consolas; background: white; color: black; font-size: 10pt">   <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">abstract</span> <span style="color: blue">class</span> <span style="color: #2b91af">MessageHandler</span>&lt;TMessage&gt; : <span style="color: #2b91af">IMessageHandler</span>&lt;TMessage&gt; <span style="color: blue">where</span> TMessage : <span style="color: #2b91af">IMessage</span></p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> Handle(TMessage message)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">try</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Process(message);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">finally</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: green">// ugly as hell, but we need this until NSB releases its resolved components</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">IoC</span>.Container.Release(<span style="color: blue">this</span>);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">protected</span> <span style="color: blue">abstract</span> <span style="color: blue">void</span> Process(TMessage message);</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p> </div>  <p>&#160;</p>  <p>Uh oh… i just felt a great disturbance in the Force, as if tens of voices suddenly cried out in terror about my direct usage of the IoC container in a component!</p>  <p>Conceptually, this is wrong on many levels.&#160; Then again, this makes sure that the message handlers (and their dependencies) that are resolved by NServiceBus will always be guaranteed to be released by the comtainer.&#160; It might not be nice, but it avoids the memory leak and it doesn’t force me to change <em>my other code</em>.</p>  <p>And once NServiceBus is modified to release the components it resolves (if it’s ever modified that is…) i only need to get rid of my custom policy and the try/finally block.&#160; Unfortunately, my existing message handlers will then all implement the Process method instead of the Handle method but that is quickly fixed with a simple rename-refactoring.</p>  <p>Even though this is a pretty big hack (IMHO), at least its impact on the code is minimal… it will be easy to get rid of once the real problem is solved in NSB, and there are no real downsides to this that i can think of at the moment. </p>