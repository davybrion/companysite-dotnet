<p>I recently posted the <a href="http://davybrion.com/blog/2009/12/agathas-caching-layer-implementation-first-draft/" target="_blank">first draft</a> of the caching implementation of Agatha.&#160; You might want to take another look at the piece of code that deals with processing requests in the Request Processor.&#160; I thought it was alright.&#160; And if only 10% of my readers actually read that code, then it means that about 200 people thought it was alright too because nobody mentioned a possible problem with that part.&#160; Today i was adding some cached requests/responses to the RequestProcessor’s <a href="http://code.google.com/p/quicknet/" target="_blank">QuickNet</a> exception handling test.&#160; And lo and behold, 2 bugs showed up that i hadn’t anticipated.</p>  <p>Before i discuss the two bugs, i’d like to explain what the exception handling quicknet test does, and how it works.&#160; It basically calls the request processing code a bunch of times, each time with a set of requests where either none, one or more of the request handlers will throw an exception during the handling of the requests.&#160; The order of the exceptions or which handlers will throw an exception is completely randomized (thanks to QuickNet) and thus it varies from test to test.&#160; This particular QuickNet test will perform 50 testruns, where each testrun consists of 50 transitions that will be executed.&#160; Each transition is a piece of functionality that will be executed (in this case, the processing of requests) with randomized input (in this case, there is a fixed set of requests but which ones will fail will differ with each run of the transition) and after a transition is executed, the relevant specs are verified (in this case, a bunch of checks to make sure that the whole error handling functionality always does what it needs to do) to make sure that the piece of code that you’re testing (your transition, in this case the processing of requests) actually works.</p>  <p>Instead of testing with a mocked caching layer, i used the real thing in the tests.&#160; I also added 2 cached request types to the test request types, and gave one of them an expiration of 1 second, the other an expiration of 2 seconds.&#160; This means that during the entire QuickNet testrun, some requests will return cached responses, some won’t, some cached responses will expire and subsequent requests of that particular type need to be executed and have their responses cached again until they expire.&#160;&#160; In the meantime, QuickNet is constantly firing requests at the RequestProcessor, and some of them will randomly fail.&#160; Our specs need to verify that the returned responses always contain the correct exception information for the batch of requests that was processed.</p>  <p>And here’s the beauty of the whole thing.&#160; I hadn’t even thought about how exception handling also influences how you deal with cached responses.&#160; I didn’t take exception handling into account when adding the caching code, and without even adding specific tests to see whether the caching worked correctly, my QuickNet specs that intended to cover something that doesn’t really have anything to do with caching uncovered 2 issues with my caching code.&#160;&#160; I was suddenly getting error messages from QuickNet that in some cases, the exception information wasn’t correct.&#160;&#160; And it frequently took over 30 executions of the transition, or sometimes multiple testruns before some of those specs would fail.&#160; The longer it takes for a bug to show up in a QuickNet test, the better the bug is at hiding and the harder it is to find it manually because it almost certainly is an edge-case that you hadn’t considered at all and that only occurs in certain situations.</p>  <p>And those are the type of bugs that you typically don’t find with traditional unit tests.&#160; When you write traditional tests that are aimed at asserting correct behavior, you typically only write tests for the problems that <em>you thought about</em>.&#160; Sometimes you’ll get lucky and traditional unit tests will inform you of incorrect behavior that you didn’t think of,&#160; but it rarely happens for the edge-cases.&#160; And those are the bugs that can be really hard and painful to find and fix.</p>  <p>By now you’re probably wondering what the two bugs are.&#160; The first one is that if an exception occurs during the handling of a request which is eligible for caching, the response with the exception information would be stored in the cache, and the next time that that particular request would be processed while the cached response hadn’t expired yet, you’d simply get the original response with the exception information again instead of actually handling the request again (which might have been handled successfully this time).&#160; The second bug was that if an earlier request in the batch of requests already failed, it could possibly return a valid response later on in the same batch for one of the cached requests if its response hadn’t expired yet.&#160;&#160; Pretty stupid huh?&#160; But they were there nevertheless, and sooner or later somebody would’ve tripped over it and it would’ve caused frustration for the user who would run into it, and pain for me because i’d have to go looking for it long after i’d written the code.</p>  <p>Again, i seriously doubt that traditional unit tests would’ve prevented the existence of these 2 problems since it never occurred to me while i was writing it.&#160; The QuickNet tests did find it, even before i added specific tests for the caching functionality to them, which i found pretty impressive and a huge benefit to this sort of testing.&#160; Granted, the learning curve for writing valuable QuickNet tests is <em>steep</em> (i’m not even halfway there IMO) and it takes a lot of effort when you’re starting out with it.&#160; But if it helps me prevent the sort of bugs that are otherwise easily missed and could negatively influence the perception of my project, then i definitely consider it worth it.</p>